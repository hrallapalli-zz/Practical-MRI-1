//-----------------------------------------------------------------------------
//  Copyright (C) Siemens AG 1998-2006  All Rights Reserved.  Confidential
//-----------------------------------------------------------------------------
//
// Project: NUMARIS/4
//
//    File: \n4\pkg\MrServers\MrImaging\seq\a_MiniFLASH.cpp
//
// Authors: Mark Brown;       SMS MED US CSG TDC;
//          Brian Dale;       SMS MED US CSG MR R&D;
//          Wolfgang Rehwald; SMS MED US CSG MR R&D;
//          Keith Heberlein;  SMS MED US CSG MR R&D;
//          
//          Original Author: Anonymous 
//
//    Lang: C++
//
// Descrip: This is the demo sequence MiniFLASH. 
//          DO NOT base any diagnosis on images generated by this sequence.
//
//////////////////////////////////////////////////////////////////////////////////////////
//
//                                MiniFLASH Sequence Diagram
//
//                       |-----------TE-------------|
//
//              RF --|sSRF01|--------------------------------------------
//
//              Gs -|sGSliSel|-|sGSliSelReph|-------------|sGSpoil|------
//
//              Gp ----------|sGPhasEnc|------------------|sGPhasEncRew|-
//
//              Gr ----------|sGReadDeph|-------|sGradRO|----------------
//
//             ADC -----------------------------|sADC01|-----------------
// 
//                |------------------------------TR----------------------|
//
///////////////////////////////////////////////////////////////////////////////////////////


#include "MrServers/MrMeasSrv/SeqIF/sde_allincludes.h" // RTEvents and objects
#include "MrServers/MrImaging/seq/SystemProperties.h " // Numaris4 system ID string

// Macro: return, if S is error code, applies to functions returning NLS
#define OnErrorReturn(S)  if (((S) & NLS_SEV) != NLS_SUCCESS) return(S)

// Prototype of function fSeqRunKernel
static NLS_STATUS fSEQRunKernel(MrProt *, SeqLim *, SeqExpo *,long ,long);

// Global variables:
long       lLinesToMeasure;
long       llinesPerSec;
long       lCenterLine;
double     dRFSpoilIncrement        = 0;
double     dRFSpoilPhase            = 0;
double     dMinRiseTime             = 100000;           // very low slew rate
double     dGradMaxAmpl             = 0;                // very low amplitude

// Declaration of used real time objects

static sSLICE_POS       asSLC[1];                       // MiniFLASH is a single-slice sequence but
                                                        // some utility functions require the use of
                                                        // an array as most sequences are multislice

static sRF_PULSE_SINC   sSRF01      ("sSRF01");         // 90 degree RF transmit waveform envelope
static sFREQ_PHASE      sSRF01zSet  ("sSRF01zSet");     // Set Frequency and phase for RF pulse
static sFREQ_PHASE      sSRF01zNeg  ("sSRF01zNeg");     // Reset synthesizer back to base
 
static sRF_PULSE_SINC   sSRF02      ("sSRF02");         // 180 degree RF transmit waveform envelope
static sFREQ_PHASE      sSRF02zSet  ("sSRF02zSet");     // Set Frequency and phase for RF pulse
static sFREQ_PHASE      sSRF02zNeg  ("sSRF02zNeg");     // Reset synthesizer back to base

static sREADOUT         sADC01      ("sADC01");         // Signal detection event
static sFREQ_PHASE      sADC01zSet  ("sADC01zSet");     // Set Frequency and phase for ADC
static sFREQ_PHASE      sADC01zNeg  ("sADC01zNeg");     // Reset synthesizer back to base

static sGRAD_PULSE      sGSliSel    ("sGSliSel");       // Gradient during RF transmit for slice selection         
static sGRAD_PULSE      sGSliSelReph("sGSliSelReph");   // Gradient to refocus slice selection gradient (after TE = 0)
static sGRAD_PULSE_RO   sGradRO     ("sGradRO");        // Gradient during echo detection
static sGRAD_PULSE      sGReadDeph  ("sGReadDeph");     // Gradient to preset readout
static sGRAD_PULSE_PE   sGPhasEnc   ("sGPhasEnc");      // Gradient for phase encoding 
static sGRAD_PULSE_PE   sGPhasEncRew("sGPhasEncRew");   // Gradient for rewinding
static sGRAD_PULSE      sGSpoil     ("sGSpoil");        // Gradient for incoherent steady-state

static sSYNC            sOscBit     ("sOscBit");        // Synchronization event for oscilloscope trigger


//.  -------------------------------------------------------------------------
//.. fSEQInit: initialize the allowed Sequence Limits
//.  -------------------------------------------------------------------------
NLS_STATUS fSEQInit (SeqLim *pSeqLim)
{

//  These entries in fSEQInit enable user interface parameters in the exam window,
//  or initialize other parameters of the sequence.

//  The parameters in this group have no meaningful default value (zero or not specified in SeqLim).

//                                 (        min,        max)
  pSeqLim->setAllowedFrequency     (    8000000,  500000000);                         // Always refers to 1H frequency

//                                 (index,  min,        max,    increment,  default)
  pSeqLim->setTR                   (    0,  100,    5000000,           10,    20000);
  pSeqLim->setTE                   (    0,  100,     100000,           10,    10000);
  pSeqLim->setBandWidthPerPixel    (    0,   80,        900,           10,      260);
  
//                                 (        min,        max,    increment,  default)
  pSeqLim->setFlipAngle            (       10.0,       90.0,          1.0,   15.000);

//  These parameters have default values, yet are added for convenience 
  
//                                 (        min,        max,    increment,  default)
  pSeqLim->setBaseResolution       (         64,        512,  SEQ::INC_64,      128); // INC_BASE2 also available  
  pSeqLim->setReadoutFOV           (        100,        500,            1,      300); // mm
  pSeqLim->setPhaseFOV             (        100,        500,            1,      300); // mm
  pSeqLim->setPELines              (         32,       1024,            1,      128);
  pSeqLim->setSlices               (          1,          1,            1,        1); // Only single slice!
  pSeqLim->setSliceThickness       (      2.000,     10.000,        0.500,    5.000); // mm


//   This compiler directive restricts this code to the HOST version dll. 
//   In this way, the same source code can be compiled for both the Host and the MPCU
//   but different portions of the code can be restricted to one processor.

#ifndef VXWORKS

//   The EVA Protocol for post-processing can be specified here.

  pSeqLim->setDefaultEVAProt (_T("%SiemensEvaDefProt%\\Inline\\Inline.evp"));

#endif

  return (SEQU__NORMAL);  
}

//. -------------------------------------------------------------------------
//.. fSEQPrep: prepare real time elements and calculate energy and timing
//. -------------------------------------------------------------------------
NLS_STATUS fSEQPrep (MrProt *pMrProt, SeqLim *pSeqLim, SeqExpo *pSeqExpo)
{
  long         lmin_required_TE, lmin_required_TR; 
  double       dMeasureTimeUsec      = 0.0;

//  Retrieve some information about the scanner and define some convenient variables
//  Hardware information is stored in proxy files. The contents can be retrieved 
//  using SysProperties methods (n4\pkg\MrServers\MrImaging\libSeqUtil\SysProperties)
  dMinRiseTime = SysProperties::getGradMinRiseTime(pMrProt->gradSpec().mode()); // Minimum gradient rise time
  dGradMaxAmpl = SysProperties::getGradMaxAmpl(pMrProt->gradSpec().mode());     // Maximum gradient amplitude
                                                                                // selected in protocol


  OnErrorReturn(pMrProt->kSpace().linesToMeasure(lLinesToMeasure));             // Call by non-constant reference
  lCenterLine  = pMrProt->kSpace().echoLine();                                  // 1/2 base resolution for symmetric PE
  dMeasureTimeUsec = (double)lLinesToMeasure * pMrProt->tr()[0];
  llinesPerSec = MAX(1,long(lLinesToMeasure * 1000000. / dMeasureTimeUsec));
  pSeqExpo->setRelevantReadoutsForMeasTime(lLinesToMeasure / llinesPerSec);


// CONFIGURE 90 degree RF PULSE PROPERTIES AND PREPARE:
  sSRF01.setTypeExcitation       ();                               // Resets all moments to 0 in Unit test
  sSRF01.setDuration             (2560);                           // Most times are in microseconds
  sSRF01.setFlipAngle            (90);           // Sets flip angle based on UI (in degrees)
  sSRF01.setInitialPhase         (0);                              // Sets phase of pulse in rotating frame to 0 (+x) 
  sSRF01.setThickness            (pMrProt->sliceSeries().aFront().thickness());  // Sets thickness based on UI (in mm)
  sSRF01.setSamples              (128);                            // Number of complex points in waveform
  sSRF01.setBandwidthTimeProduct (2.70);                        // Only sRF_PULSE_SINC objects have the BW*t attribute 
  
  // CONFIGURE  180 degree RF PULSE PROPERTIES AND PREPARE:
  sSRF02.setTypeExcitation       ();                               // Resets all moments to 0 in Unit test
  sSRF02.setDuration             (2560);                           // Most times are in microseconds
  sSRF02.setFlipAngle            (180);           // Sets flip angle based on UI (in degrees)
  sSRF02.setInitialPhase         (0);                              // Sets phase of pulse in rotating frame to 0 (+x) 
  sSRF02.setThickness            (pMrProt->sliceSeries().aFront().thickness());  // Sets thickness based on UI (in mm)
  sSRF02.setSamples              (128);                            // Number of complex points in waveform
  sSRF02.setBandwidthTimeProduct (2.70);                        // Only sRF_PULSE_SINC objects have the BW*t attribute 

//  The following is a common error-checking code structure for pulse sequences. 
//  The prepare (prep) method returns a boolean indicating success or failure. 
//  If the returned boolean indicates failure, then exit fSEQPrep and return the NLS error code.
  if(! sSRF01.prepSinc(pMrProt,pSeqExpo)) return (sSRF01.getNLSStatus());
  if(! sSRF02.prepSinc(pMrProt,pSeqExpo)) return (sSRF02.getNLSStatus());


//  PREPARE ADC:
  sADC01.setColumns (pMrProt->kSpace().baseResolution());
  sADC01.setDwellTime (long((pMrProt->rxSpec().effDwellTime(pSeqLim->getReadoutOSFactor())[0]) + 0.5));
  sADC01.Mdh.setKSpaceCentreColumn((unsigned short)(pMrProt->kSpace().baseResolution()/2));

 //  An explicit preparation for the ADC is not necessary as setDwellTime() includes .prep

//  PREPARE THE READOUT GRADIENT:
//  The method .prepRO() sets only the amplitude based on the UI settings.
//  The ramp times and the duration need to be set separately.
//  Note that the duration is defined as the RampUpTime plus the FlatTopTime.
//  The method .check() ensures that amplitude and slew rate limits are not exceeded.

  if(!sGradRO.prepRO(pMrProt,sADC01.getDwellTime()))return(sGradRO.getNLSStatus());
  sGradRO.setRampTimes(fSDSRoundUpGRT(dMinRiseTime*sGradRO.getAmplitude()));
  sGradRO.setDuration(fSDSRoundUpGRT(sGradRO.getRampUpTime()+sADC01.getDuration()));
  if(!sGradRO.check()) return (sGradRO.getNLSStatus());

//  The start time of the readout gradient cannot be set because the slice select gradient timing has not 
//  been determined. Once the TE in the UI is known to be consistent (i.e. if it is greater than the minimum 
//  required TE), the start time can be set.


//  PREPARE AND CHECK THE PHASE ENCODING GRADIENT:
//  First, chose maximum allowed value for gradient performance.
  sGPhasEnc.setMaxMagnitude(dGradMaxAmpl);     // set highest performance value (maximum allowed gradient amplitude)
  sGPhasEnc.setMinRiseTime(dMinRiseTime);      // set highest performance value (shortest allowed gradient rise time)
                                               // rise time is 1/slew rate; unit of rise time is [us/(mT/m)]
//  Second, prepare gradient for positive edge of k-space ...
  if( !sGPhasEnc.prepPEShortestTime(pMrProt, SEQ::DIR_ASCENDING, 0.0, lLinesToMeasure - lCenterLine - 1))
	  return(sGPhasEnc.getNLSStatus()); 

//  .. and check if amplitude and rise time do not exceed maximum allowed values.
  if( !sGPhasEnc.check()) return(sGPhasEnc.getNLSStatus());

//  Remember the duration, before praparing the other edge of k-space
  long lPhaseEncTotalTime = sGPhasEnc.getTotalTime();

//  Third, prepare gradient for negative edge of k-space ...
  if( !sGPhasEnc.prepPEShortestTime(pMrProt, SEQ::DIR_ASCENDING, 0.0, -lCenterLine )) return(sGPhasEnc.getNLSStatus()); 

//  .. and check if amplitude and rise time do not exceed maximum allowed values.
  if( !sGPhasEnc.check()) return(sGPhasEnc.getNLSStatus());

//  Take the longer duration of both edges by re-preparing the gradient, if needed
  if (lPhaseEncTotalTime > sGPhasEnc.getTotalTime())
      if( !sGPhasEnc.prepPEShortestTime(pMrProt, SEQ::DIR_ASCENDING, 0.0, lLinesToMeasure - lCenterLine - 1))
    	  return(sGPhasEnc.getNLSStatus()); 

//  Copy timing info to PE rewinder as this gradient will have same timing (but opposite polarity) as phase encoder.
  sGPhasEncRew = sGPhasEnc;


//  PREPARE AND CHECK THE SLICE SELECTION GRADIENT:
//  First, set the gradient amplitude, retrieving it from the RF pulse object.
  sGSliSel.setAmplitude(sSRF01.getGSAmplitude());
  sGSliSel.setAmplitude(sSRF02.getGSAmplitude());

//  Second, set the ramp-up and ramp-down times. The variable dMinRiseTime is the inverse of the slew rate [us*m/mT],
//  the .getAmplitude() method delivers the amplitude in mT/m. The coil lead time is the minimum time needed between
//  the beginning of an event block and the start time of the RF pulse shape. If the needed lead time is longer than
//  the calculated minimum ramp-up time, then set the ramp-up time to the coil lead time.
  sGSliSel.setRampTimes(fSDSRoundUpGRT(MAX(dMinRiseTime * sGSliSel.getAmplitude(), SysProperties::getCoilCtrlLead())));

//  Third, set the duration of the gradient. Gradient "duration" is defined as the duration of the ramp-up plus
//  the duration of the plateau. The ramp-down duration is NOT included.
  sGSliSel.setDuration(fSDSRoundUpGRT(sSRF01.getDuration() + sGSliSel.getRampUpTime()));

//  Fourth, prepare and check if the gradient is correctly prepared (slew rate and maximum amplitude not exceeded).
  if (!sGSliSel.prep())  return (sGSliSel.getNLSStatus());
  if (!sGSliSel.check()) return (sGSliSel.getNLSStatus());

//  Finally, set start time of gradient to zero, as this is the first event in the event block. In general, setting 
//  the start time is not required for passing the check. However, it is required if the gradient is played out 
//  by using the .run() method rather than by using the fRTEI function in the fSEQRunKernel function.
//  Setting the start time is also a useful feature for getting timing information, e.g. in fSEQRunKernel.
  sGSliSel.setStartTime(0);


//  PREPARE AND CHECK THE SLICE REPHASE GRADIENT:
//  Set the area equal to the slice select gradient from TE = 0 to the end (assuming a symmetric RF pulse).
//  Use the shortest time possible.
  sGSliSelReph.setMaxMagnitude(dGradMaxAmpl);
  sGSliSelReph.setMinRiseTime (dMinRiseTime);
  if (!sGSliSelReph.prepSymmetricTOTShortestTime(-sGSliSel.getMomentum(sGSliSel.getDuration() 
         - sSRF01.getDuration()/2,sGSliSel.getTotalTime()))) 
           return (sGSliSelReph.getNLSStatus()); 


//  PREPARE AND CHECK THE READOUT DEPHASING GRADIENT:
//  Set the area equal to the readout gradient up to TE (assuming symmetric sampling).
//  Use the shortest time possible.
  sGReadDeph.setMaxMagnitude(dGradMaxAmpl);
  sGReadDeph.setMinRiseTime (dMinRiseTime);
  if (!sGReadDeph.prepSymmetricTOTShortestTime(-sGradRO.getMomentum(0,sGradRO.getRampUpTime() + (long)(sADC01.getDuration()/2))))
      return (sGReadDeph.getNLSStatus());


//  PREPARE AND CHECK THE SPOILER GRADIENT:
//  Set the area to half that of the slice select gradient, and use the shortest time possible.
  sGSpoil.setMaxMagnitude(dGradMaxAmpl);
  sGSpoil.setMinRiseTime (dMinRiseTime);
  if(!sGSpoil.prepSymmetricTOTShortestTime(sGSliSel.getMomentumTOT()/2)) 
       return (sGSpoil.getNLSStatus());


//  Calculate minimum required TE by finding the time-dominant (longest) gradient of sGReadDeph, sGPhasEnc, and 
//  sGSliceSelReph. Note that sGSliceSelReph is started when sGSliSel has ramped down, whereas sGReadDeph and sGPhasEnc
//  are started at the end of the plateau of sGSliSel.

//  First, see how long TE needs to be if sGReadDeph is longest:
  lmin_required_TE = sSRF01.getDuration()/2 + sGReadDeph.getTotalTime() + sGradRO.getRampUpTime() 
                           + sADC01.getRoundedDuration()/2;

//  Second, compare this TE to the TE necessary if sGPhasEnc is longest:
  lmin_required_TE = MAX(lmin_required_TE, sSRF01.getDuration()/2 + sGPhasEnc.getTotalTime() 
                           + sGradRO.getRampUpTime() + sADC01.getRoundedDuration()/2);

//  Finally, compare this TE to the TE necessary if sGSliSelReph is longest:
  lmin_required_TE = MAX(lmin_required_TE, sSRF01.getDuration()/2 + sGSliSel.getRampDownTime() 
                           + sGSliSelReph.getTotalTime() + sGradRO.getRampUpTime() + sADC01.getRoundedDuration()/2);


//  DETERMINE IF THE REQUIRED TIMING CAN BE ACCOMMODATED BY THE TE IN THE PROTOCOL:
//  If the minimum required TE is larger than the TE specified in the protocol, then return an error code 
//  Ã¬SBB_NEGATIV_TEFILL". This error will cause the UI to increase the TE (pMrProt->te()[0]) until the function 
//  fSEQPrep no longer returns an error. Then the TE value is found that is consistent.
  if (lmin_required_TE > long(pMrProt->te()[0]) ) return SBB_NEGATIV_TEFILL ;


//  Set the start time of the readout gradient sGradRO
  sGradRO.setStartTime(fSDSRoundUpGRT(sGSliSel.getDuration() - sSRF01.getDuration()/2 + pMrProt->te()[0]
            - sADC01.getRoundedDuration()/2 - sGradRO.getRampUpTime()));

//  Set the start time of the ADC event sADC01
  sADC01.setStartTime(sGradRO.getStartTime() + sGradRO.getRampUpTime());


//  DETERMINE IF THE REQUIRED TIMING CAN BE ACCOMODATED BY THE TR IN THE PROTOCOL:
//  If the minimum required TR is larger than the TR chosen in the protocol, then return an error code 
//  "SBB_NEGATIV_TRFILL". This error will cause the UI to increase the TR (pMrProt->tr()[0]) until the function 
//   fSEQPrep no longer returns an error. Then the TR value is found that is consistent. 
  
  lmin_required_TR = (long)(sGSliSel.getTotalTime()/2) + long(pMrProt->te()[0]) + long(sADC01.getDuration()/2) 
                                + MAX(sGPhasEncRew.getTotalTime(), sGSpoil.getTotalTime());
  if (lmin_required_TR > long(pMrProt->tr()[0]) ) return SBB_NEGATIV_TRFILL ;

//  PREPARE THE SYNCHRONIZATION EVENT:
//  Since it occurs at the same time as the slice gradient at the beginning of the event block 
//  and is of shorter duration, it need not be included the timing checks.
  sOscBit.lCode = SYNCCODE_OSC0;                                   // Internal designation for port 0 on MPCU
  sOscBit.setDuration (10);                                        // Duration in us

//  Set receiver gain
  OnErrorReturn(fSSLSetRxGain(K_RX_GAIN_CODE_HIGH,pMrProt,pSeqLim));
//  Prepare the slice position array
  OnErrorReturn(fSUPrepSlicePosArray (pMrProt, pSeqLim, asSLC));

//  Set sequence string for display in images.
  fSUSetSequenceString              ("fl", pMrProt, pSeqExpo); 

//  Fill export section - Much of this information is transferred to the YAPS buffer in the ICE program 
  pSeqExpo->setRFEnergyInSequence_Ws	(lLinesToMeasure * sSRF01.getPulseEnergyWs());       // Mandatory
  pSeqExpo->setMeasuredPELines      	(lLinesToMeasure);                                   // Mandatory
  pSeqExpo->setMeasureTimeUsec      	(dMeasureTimeUsec);                                  // Mandatory
  pSeqExpo->setTotalMeasureTimeUsec 	(dMeasureTimeUsec);                                  // Mandatory
  pSeqExpo->setPCAlgorithm       		(SEQ::PC_ALGORITHM_NONE);                            // Mandatory
  pSeqExpo->setOnlineFFT         		(SEQ::ONLINE_FFT_PHASE);                             // Necessary for 
                                                                                             // IceProgramOnline2D

//  An ICE program must be specified in order for the MRIR to be active during scan 
  pSeqExpo->setICEProgramFilename   ("%SiemensIceProgs%\\IceProgramOnline2D");         // Only 2D reconstruction allowed

  return (SEQU__NORMAL);
}

//. -------------------------------------------------------------------------
//.. fSEQCheck: check lines at the border of k-space (gradient overflow, GSWD)
//. -------------------------------------------------------------------------
NLS_STATUS fSEQCheck(MrProt *pMrProt, SeqLim *pSeqLim, SeqExpo *pSeqExpo, SEQCheckMode *pSEQCheckMode)
{        
  long        lL                = 0;
  long        alLCk[4]          = {0, 1, pSeqExpo->getMeasuredPELines() - 2, 
                                         pSeqExpo->getMeasuredPELines() - 1};                // line numbers for first
                                                                                             // two and last two lines
  // ------------------------------------------------------
  // Dummy variable to avoid compiler warning about unused variables
  // ------------------------------------------------------
  #ifndef VXWORKS
    SEQCheckMode *dummy ;
    dummy = pSEQCheckMode ;
  #endif

  while (lL < 4 )
    {
      OnErrorReturn(fSEQRunKernel(pMrProt, pSeqLim, pSeqExpo, KERNEL_CHECK, alLCk[lL]));
      lL++;
    }
  return(SEQU__NORMAL);
}

//. -------------------------------------------------------------------------
//.. fSEQRun: run the sequence
//. -------------------------------------------------------------------------
NLS_STATUS fSEQRun(MrProt  *pMrProt, SeqLim  *pSeqLim, SeqExpo *pSeqExpo)
{
//  Initialize the sequence test.
  mSEQTest (pMrProt, pSeqLim, pSeqExpo, RTEB_ORIGIN_fSEQRunStart, 0, 0, 0, 0, 0); 

  long lLine;
  long lCurrKernelCalls = 0;

//  Send the delay between measurements (multiple measurements not used in MiniFLASH).
  OnErrorReturn(fSBBMeasRepetDelaysRun ( pMrProt, pSeqLim, pSeqExpo, 0 ));

//  Fill some entries of the measurement data header.
//  These entries are constant for all lines and will not change from line to line.
  sADC01.Mdh.setEvalInfoMask(sADC01.Mdh.getEvalInfoMask() | MDH_ONLINE);          // add online priority processing
  sADC01.Mdh.setKSpaceCentreLineNo((unsigned short)pMrProt->kSpace().echoLine()); // (= Base Resolution / 2).
  sADC01.Mdh.setKSpaceCentrePartitionNo(0);                                       // 2D sequence 

  mSEQTest (pMrProt, pSeqLim, pSeqExpo, RTEB_ClockInitTR, 0, 0, asSLC[0].getSliceIndex(), 0, 0);

//  Loop over lines.
  for (lLine = 0; lLine < lLinesToMeasure; lLine++ ) 
    { 
      lCurrKernelCalls ++;

//  Fill some entries of the measurement data header. These entries can change from line to line.
      if(!(lCurrKernelCalls % llinesPerSec)) sADC01.setRelevantForMeasTime();
      sADC01.Mdh.setFirstScanInSlice( lLine == 0 );                             // only true if lLine = 0 (first line)
      sADC01.Mdh.setLastScanInSlice ( lLine == lLinesToMeasure - 1);            // only true if lLine = last line
      sADC01.Mdh.setLastScanInConcat( lLine == lLinesToMeasure - 1);
      sADC01.Mdh.setLastScanInMeas  ( lLine == lLinesToMeasure - 1);

      
//  Call Kernel function
//  If the kernel is successful, then loop again; otherwise, exit fSEQRun immediately and return error code
      OnErrorReturn(fSEQRunKernel(pMrProt, pSeqLim, pSeqExpo, KERNEL_IMAGE, lLine));
    }

//  Finish the sequence test.
  mSEQTest(pMrProt,pSeqLim,pSeqExpo,RTEB_ORIGIN_fSEQRunFinish,0,0,0,0,0); 
  return(SEQU__NORMAL);
}

//. -------------------------------------------------------------------------
//.. fSEQRunKernel
//. -------------------------------------------------------------------------
static NLS_STATUS fSEQRunKernel(MrProt *pMrProt, SeqLim *pSeqLim, SeqExpo *pSeqExpo, long lKernelMode, long lLine)
{
//  Prepare Phase encoding and rewinder gradients.
  if(!sGPhasEnc.prepPE(pMrProt, lLine - lCenterLine)) return(sGPhasEnc.getNLSStatus());
  if(!sGPhasEncRew.prepPE(pMrProt, lCenterLine - lLine)) return (sGPhasEncRew.getNLSStatus());

//  Fill measurement data header. These entries also can change from line to line
  sADC01.Mdh.setClin            ((unsigned short) lLine);  
  sADC01.Mdh.setPhaseFT         (lLine == lLinesToMeasure - 1);

//  Prepare FrequencyPhase objects of the RF pulse.
  sSRF01zSet.prepSet (asSLC[0], sSRF01) ;
  sSRF01zNeg.prepNeg (asSLC[0], sSRF01) ;

//  Prepare FrequencyPhase objects of the ADC.
  sADC01zSet.prepSet (asSLC[0], sADC01, sGradRO, lLine-lCenterLine, 0) ;
  sADC01zNeg.prepNeg (asSLC[0], sADC01, sGradRO, lLine-lCenterLine, 0) ;

//  Calculate additional phase needed for RF spoiling and add to FreqPhase objects for RF pulse and ADC.
  dRFSpoilIncrement += RFSPOIL_INCREMENTdeg ;
  dRFSpoilPhase     += dRFSpoilIncrement ;
  dRFSpoilPhase      = fmod(dRFSpoilPhase,     (double) RFMAXPHASEdeg);
  dRFSpoilIncrement  = fmod(dRFSpoilIncrement, (double) RFMAXPHASEdeg);

  sADC01zSet.increasePhase(dRFSpoilPhase);
  sADC01zNeg.decreasePhase(dRFSpoilPhase);

  sSRF01zSet.increasePhase(dRFSpoilPhase);
  sSRF01zNeg.decreasePhase(dRFSpoilPhase);

//  Initialize real time event block with rotation matrix from slice
  fRTEBInit(&asSLC[0].m_sROT_MATRIX); 
// - **************************************** S E Q U E N C E   T I M I N G ************************************
// - *           Start Time    |    NCO    |  SRF  |  ADC  |             Gradient Events             | Sync  
// - *             (usec)      |   Event   | Event | Event |     phase    |   read     |    slice    | Event 
// - *fRTEI(                   ,           ,       ,       ,              ,            ,             ,        );
// - ***********************************************************************************************************
//  Play out the slice encoding gradient and oscilloscope trigger as first event in the event block.
  fRTEI(                       0,          0,      0,      0,            0,            0,    &sGSliSel,&sOscBit);
  
//  Play out the RF pulse shape and set the frequency/phase object of the pulse to the new value.
  fRTEI(sGSliSel.getDuration()
        - sSRF01.getDuration()  ,&sSRF01zSet,&sSRF01,      0,            0,            0,            0,       0);
  
//  At the end of the RF Pulse, reset the frequency and phase object back to its value prior to the pulse. 
//  In the same event, play out the phase encoding and the read dephasing gradients.
  fRTEI(sGSliSel.getDuration()  ,&sSRF01zNeg,      0,      0,   &sGPhasEnc,  &sGReadDeph,            0,       0);
  
//  Play the slice rephasing gradient beginning at the end of the slice select gradient.
  fRTEI(sGSliSel.getTotalTime() ,          0,      0,      0,            0,            0,&sGSliSelReph,       0);
  
//  Play the readout gradient at its start time calculated above as a function of TE. 
  fRTEI(sGradRO.getStartTime()  ,          0,      0,      0,            0,     &sGradRO,            0,       0);
  
//  Turn on the ADC to measure the signal. Just as for the RF pulse, a frequency/phase object must accompany 
//  the ADC at its beginning and its end.
  fRTEI(sADC01.getStartTime()   ,&sADC01zSet,      0,&sADC01,            0,            0,            0,       0);
  fRTEI(sADC01.getStartTime()
   + sADC01.getRoundedDuration(),&sADC01zNeg,      0,      0,            0,            0,            0,       0);
  
//  Play the phase encoding rewinder and the spoiler gradients.
  fRTEI(sGradRO.getStartTime()
        + sGradRO.getDuration() ,          0,      0,      0,&sGPhasEncRew,            0,     &sGSpoil,       0);
  
//  Finish the event block: include an instruction occurring at TR so that the event block is at least this long.
//  No objects are played out at this time (indicated by all zeroes). As the timing has been checked to fit
//  into TR, the start time of this event occurs when the last gradient has ramped down.
  fRTEI(pMrProt->tr()[0]        ,          0,      0,      0,            0,            0,            0,       0);

// Several other methods of calling fRTEI instructions are available (MrServers\MrMeasSrv\SeqIF\libRT\libRT.h):
// The first is to call fRTEI and only pass a start time and one object (other than gradients):
// fRTEI(sGPhasEnc.getStartTime(), &sSRF01zNeg);
//
// The second is to call fRTEI and pass a start time and three gradient objects:
// fRTEI(sGSpoil.getStartTime(), &sGPhasEncRew, 0, &sGSpoil);
//
// The last is to call fRTEI and pass only a start time:
// fRTEI(pMrProt->tr()[0]);
//
// Instead of calling fRTEI, a more object-oriented approach can be used: the .run() method.
// In this case, the start time of each object must be specified using the .setStartTime method:
//		sSRF01.setStartTime(...);
//
// If this has been done (e.g, in fSEQPrep), then only the .run() method can be called in the event block:
//		sSRF01.run();
//
// To use this method with a gradient object, the logical axis for the object must also be 
// specified prior to its use (in fSeqPrep or fSeqRun):
// sGradRO.setAxis(SEQ::AXIS_READOUT).

// Call sequence unit test.
  if (lKernelMode == KERNEL_CHECK) 
      mSEQTest(pMrProt, pSeqLim, pSeqExpo, RTEB_ORIGIN_fSEQCheck,     10, lLine, asSLC[0].getSliceIndex(), 0, 0);
  else
      mSEQTest(pMrProt, pSeqLim, pSeqExpo, RTEB_ORIGIN_fSEQRunKernel, 10, lLine, asSLC[0].getSliceIndex(), 0, 0);

      mSEQTest(pMrProt, pSeqLim, pSeqExpo, RTEB_ClockCheck, 10, lLine, asSLC[0].getSliceIndex(), 0, 0);

//  End real time event block.
  OnErrorReturn(fRTEBFinish());

  return(SEQU__NORMAL); 
}
